package io.exoquery.xr.copy

// TODO probably want this to be auto-generated by Decomat similar to the csf functions
//      etc... but it needs to be generated in a different package because we DONT want to import XR.Elem.Elem functions everywhere

import io.exoquery.BID
import io.exoquery.xr.*
import io.exoquery.xr.XR.ConcatMap
import io.exoquery.xr.XR.Entity
import io.exoquery.xr.XR.Filter
import io.exoquery.xr.XR.Map
import io.exoquery.xr.XR.QueryOf
import io.exoquery.xr.XR.ValueOf
import io.exoquery.xr.XR.SortBy
import io.exoquery.xr.XR.GroupByMap
import io.exoquery.xr.XR.Take
import io.exoquery.xr.XR.Drop
import io.exoquery.xr.XR.Union
import io.exoquery.xr.XR.UnionAll
import io.exoquery.xr.XR.FlatMap
import io.exoquery.xr.XR.FlatJoin
import io.exoquery.xr.XR.FlatGroupBy
import io.exoquery.xr.XR.FlatSortBy
import io.exoquery.xr.XR.FlatFilter
import io.exoquery.xr.XR.Distinct
import io.exoquery.xr.XR.DistinctOn
import io.exoquery.xr.XR.Nested
import io.exoquery.xr.XR.Infix
import io.exoquery.xr.XR.Function1
import io.exoquery.xr.XR.FunctionN
import io.exoquery.xr.XR.FunctionApply
import io.exoquery.xr.XR.BinaryOp
import io.exoquery.xr.XR.UnaryOp
import io.exoquery.xr.XR.Aggregation
import io.exoquery.xr.XR.MethodCallName
import io.exoquery.xr.XR.MethodCall
import io.exoquery.xr.XR.GlobalCall
import io.exoquery.xr.XR.Ident
import io.exoquery.xr.XR.TagForSqlExpression
import io.exoquery.xr.XR.TagForSqlQuery
import io.exoquery.xr.XR.TagForParam
import io.exoquery.xr.XR.Product
import io.exoquery.xr.XR.Property
import io.exoquery.xr.XR.Block
import io.exoquery.xr.XR.When
import io.exoquery.xr.XR.Branch
import io.exoquery.xr.XR.Variable

val Entity.Entity get() = this
fun Entity.cs(name: String) = io.exoquery.xr.XR.Entity.csf(name)(this)

val Filter.Filter get() = this
fun Filter.cs(head: XR.Query, id: XR.Ident, body: XR.Expression) = io.exoquery.xr.XR.Filter.csf(head, id, body)(this)

val Map.Map get() = this
fun Map.cs(head: XR.Query, id: XR.Ident, body: XR.Expression) = io.exoquery.xr.XR.Map.csf(head, id, body)(this)

val ConcatMap.ConcatMap get() = this
fun ConcatMap.cs(head: XR.Query, id: XR.Ident, body: XR.Expression) = io.exoquery.xr.XR.ConcatMap.csf(head, id, body)(this)

val ValueOf.ValueOf get() = this
fun ValueOf.cs(head: XR.Query) = io.exoquery.xr.XR.ValueOf.csf(head)(this)

val QueryOf.QueryOf get() = this
fun QueryOf.cs(head: XR.Expression) = io.exoquery.xr.XR.QueryOf.csf(head)(this)

val SortBy.SortBy get() = this
fun SortBy.cs(head: XR.Query, id: XR.Ident, criteria: XR.Expression, ordering: XR.Ordering) = io.exoquery.xr.XR.SortBy.csf(head, id, criteria, ordering)(this)

val GroupByMap.GroupByMap get() = this
fun GroupByMap.cs(head: XR.Query, byAlias: Ident, byBody: XR.Expression, mapAlias: Ident, mapBody: XR.Expression) = io.exoquery.xr.XR.GroupByMap.csf(head, byAlias, byBody, mapAlias, mapBody)(this)

val Take.Take get() = this
fun Take.cs(head: XR.Query, num: XR.Expression) = io.exoquery.xr.XR.Take.csf(head, num)(this)

val Drop.Drop get() = this
fun Drop.cs(head: XR.Query, num: XR.Expression) = io.exoquery.xr.XR.Drop.csf(head, num)(this)

val Union.Union get() = this
fun Union.cs(a: XR.Query, b: XR.Query) = io.exoquery.xr.XR.Union.csf(a, b)(this)

val UnionAll.UnionAll get() = this
fun UnionAll.cs(a: XR.Query, b: XR.Query) = io.exoquery.xr.XR.UnionAll.csf(a, b)(this)

val FlatMap.FlatMap get() = this
fun FlatMap.cs(head: XR.Query, id: XR.Ident, body: XR.Query) = io.exoquery.xr.XR.FlatMap.csf(head, id, body)(this)

val FlatJoin.FlatJoin get() = this
fun FlatJoin.cs(head: XR.Query, id: XR.Ident, on: XR.Expression) = io.exoquery.xr.XR.FlatJoin.csf(head, id, on)(this)

val FlatGroupBy.FlatGroupBy get() = this
fun FlatGroupBy.cs(by: XR.Expression) = io.exoquery.xr.XR.FlatGroupBy.csf(by)(this)

val FlatSortBy.FlatSortBy get() = this
fun FlatSortBy.cs(by: XR.Expression, ordering: XR.Ordering) = io.exoquery.xr.XR.FlatSortBy.csf(by, ordering)(this)

val FlatFilter.FlatFilter get() = this
fun FlatFilter.cs(by: XR.Expression) = io.exoquery.xr.XR.FlatFilter.csf(by)(this)

val Distinct.Distinct get() = this
fun Distinct.cs(head: XR.Query) = io.exoquery.xr.XR.Distinct.csf(head)(this)

val DistinctOn.DistinctOn get() = this
fun DistinctOn.cs(head: XR.Query, id: XR.Ident, by: XR.Expression) = io.exoquery.xr.XR.DistinctOn.csf(head, id, by)(this)

val Nested.Nested get() = this
fun Nested.cs(head: XR.Query) = io.exoquery.xr.XR.Nested.csf(head)(this)

val Infix.Infix get() = this
fun Infix.cs(parts: List<String>, params: List<XR>) = io.exoquery.xr.XR.Infix.csf(parts, params)(this)

val Function1.Function1 get() = this
fun Function1.cs(param: XR.Ident, body: XR.Expression) = io.exoquery.xr.XR.Function1.csf(param, body)(this)

val FunctionN.FunctionN get() = this
fun FunctionN.cs(params: List<Ident>, body: XR.Expression) = io.exoquery.xr.XR.FunctionN.csf(params, body)(this)

val FunctionApply.FunctionApply get() = this
fun FunctionApply.cs(function: XR.Expression, args: List<XR.Expression>) = io.exoquery.xr.XR.FunctionApply.csf(function, args)(this)

val BinaryOp.BinaryOp get() = this
fun BinaryOp.cs(a: XR.Expression, op: BinaryOperator, b: XR.Expression) = io.exoquery.xr.XR.BinaryOp.csf(a, op, b)(this)

val UnaryOp.UnaryOp get() = this
fun UnaryOp.cs(op: UnaryOperator, expr: XR.Expression) = io.exoquery.xr.XR.UnaryOp.csf(op, expr)(this)

val Aggregation.Aggregation get() = this
fun Aggregation.cs(op: AggregationOperator, expr: XR.Expression) = io.exoquery.xr.XR.Aggregation.csf(op, expr)(this)

val MethodCallName.MethodCallName get() = this
fun MethodCallName.cs(name: XR.FqName, originalHostType: XR.FqName) = io.exoquery.xr.XR.MethodCallName.csf(name, originalHostType)(this)

val MethodCall.MethodCall get() = this
fun MethodCall.cs(head: XR.Expression, args: List<XR.Expression>) = io.exoquery.xr.XR.MethodCall.csf(head, args)(this)

val GlobalCall.GlobalCall get() = this
fun GlobalCall.cs(args: List<XR.Expression>) = io.exoquery.xr.XR.GlobalCall.csf(args)(this)

val Ident.Ident get() = this
fun Ident.cs(name: String) = io.exoquery.xr.XR.Ident.csf(name)(this)

val TagForSqlExpression.TagForSqlExpression get() = this
fun TagForSqlExpression.cs(id: BID) = io.exoquery.xr.XR.TagForSqlExpression.csf(id)(this)

val TagForSqlQuery.TagForSqlQuery get() = this
fun TagForSqlQuery.cs(id: BID) = io.exoquery.xr.XR.TagForSqlQuery.csf(id)(this)

val TagForParam.TagForParam get() = this
fun TagForParam.cs(id: BID) = io.exoquery.xr.XR.TagForParam.csf(id)(this)

val Product.Product get() = this
fun Product.cs(fields: List<Pair<String, XR.Expression>>) = io.exoquery.xr.XR.Product.csf(fields)(this)

val Property.Property get() = this
fun Property.cs(of: XR.Expression, name: String) = io.exoquery.xr.XR.Property.csf(of, name)(this)

val Block.Block get() = this
fun Block.cs(stmts: List<Variable>, output: XR.Expression) = io.exoquery.xr.XR.Block.csf(stmts, output)(this)

val When.When get() = this
fun When.cs(branches: List<Branch>, orElse: XR.Expression) = io.exoquery.xr.XR.When.csf(branches, orElse)(this)

val Branch.Branch get() = this
fun Branch.cs(cond: XR.Expression, then: XR.Expression) = io.exoquery.xr.XR.Branch.csf(cond, then)(this)

val Variable.Variable get() = this
fun Variable.cs(name: XR.Ident, rhs: XR.Expression) = io.exoquery.xr.XR.Variable.csf(name, rhs)(this)
